#lang racket

(define (leer-fichero-listas-sin-indice ruta)
  (call-with-input-file ruta
    (lambda (in)
      (let loop ((linea (read-line in 'any))
                 (acumulador '()))
        (if (eof-object? linea)
            (reverse acumulador)
            (let* ((partes (string-split linea ":"))
                   (numeros-str (if (> (length partes) 1)
                                    (cadr partes)
                                    ""))
                   (numeros (filter number?
                                    (map string->number
                                         (string-split numeros-str))))
                   (ordenados (sort numeros <)))
              (loop (read-line in 'any) (cons ordenados acumulador))))))))

(define entrada (leer-fichero-listas-sin-indice "04_dat_01.txt"))

;; utilidades
(define (miembro? x xs) (and (member x xs) #t))
(define (union-uniqs a b)
  (foldl (lambda (x acc) (if (miembro? x acc) acc (cons x acc))) a b))
(define (diff a b) (filter (lambda (x) (not (miembro? x b))) a))
(define (todas-habs datos) (foldl (lambda (h acc) (union-uniqs acc h)) '() datos))
(define (nuevas-habs habs-sel cand) (diff cand habs-sel))

(define (restos datos i habs-sel)
  ;; secuencia de conjuntos de habilidades nuevas de los candidatos desde i
  (let loop ((k 0) (acc '()) (ds datos))
    (cond [(null? ds) (reverse acc)]
          [(< k i) (loop (+ k 1) acc (cdr ds))]
          [else (loop (+ k 1) (cons (nuevas-habs habs-sel (car ds)) acc) (cdr ds))])))

(define (mayor-incr datos i habs-sel)
  (let loop ((rs (restos datos i habs-sel)) (m 0))
    (if (null? rs) m (loop (cdr rs) (max m (length (car rs)))))))

(define (alcanzables datos i habs-sel)
  (foldl (lambda (r acc) (union-uniqs acc r)) '() (restos datos i habs-sel)))

(define (cota datos card miembros habs-sel i)
  (let* ((hay (length miembros))
         (faltan (- card (length habs-sel))))
    (cond
      [(<= faltan 0) hay]
      [else
       (define todas (alcanzables datos i habs-sel))
       (define maxinc (mayor-incr datos i habs-sel))
       (if (or (< (length todas) faltan) (= maxinc 0))
           +inf.0
           (+ hay (ceiling (/ faltan maxinc))))])))

(define (lanza datos card miembros habs-sel i mejor-mejor t-mejor)
  ;; DFS con poda
  (let ((ct (cota datos card miembros habs-sel i)))
    (cond
      [(>= ct t-mejor) (values mejor-mejor t-mejor)]
      [(>= (length habs-sel) card) (values miembros ct)]
      [else
       (define mejor mejor-mejor)
       (define t t-mejor)
       (let loop ((k i) (ds datos))
         (cond
           [(null? ds) (values mejor t)]
           [else
            (define cand (car ds))
            (define miembros2 (cons cand miembros))
            (define habs2 (union-uniqs habs-sel (nuevas-habs habs-sel cand)))
            (define-values (mej-act t-act)
              (lanza datos card miembros2 habs2 (+ k 1) mejor t))
            (set! mejor mej-act)
            (set! t t-act)
            (loop (+ k 1) (cdr ds)))]))])))

(define (Parcial-RyP datos)
  (define card (length (todas-habs datos)))
  (define-values (mejor t)
    (lanza datos card '() '() 0 '() +inf.0))
  (reverse mejor))
